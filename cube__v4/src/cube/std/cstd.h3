
#include("ctype.h")

namespace std.ctype {

	public static bool isalnum(int c);
	
	public static bool isalpha(int c);
	
	public static bool iscntrl(int c);
	
	public static bool isdigit(int c);
	
	/**  Is printing character other than space */
	public static bool isgraph(int c);
	
	public static bool islower(int c);
	
	/**  
	 * Is printing character (including space). 
	 * In ASCII, printing characters are 0x20 (' ') to 0x7E ('~') 
	 */
	public static bool isprint(int c);
	
	public static bool ispunct(int c);

	public static bool isspace(int c);
	
	public static bool isupper(int c);
	
	public static bool isxdigit(int c);

	public static bool tolower(int c);
	
	public static bool toupper(int c);
}

#include("string.h")

namespace std.string {

	//typedef uint size_t;
	
	Type for objects declared to store result of sizeof operator.
    
	public static string strcpy(string s, const string ct);
	
	public static string strncpy(string s, const string ct, size_t n);
	
	public static string strcat(string s, const string ct);
	
	public static string strncat(string s, const string ct, size_t n);

	public static int strcmp(const string cs, const string ct);
	
	public static int strncmp(const string cs, const string ct, size_t n);
	
	public static int strcoll(const string cs, const string ct);
	
	public static unsafe char* strchr(const string cs, int c);
	
	public static unsafe char* strrchr(const string cs, int c);
	
	public static size_t strspn(const string cs, const string ct);

	public static size_t strcspn(const string cs, const string ct);
	
	public static unsafe char* strpbrk(const string cs, const string ct);
  
	public static unsafe char* strstr(const string cs, const string ct);

	public static size_t strlen(const string cs);
    
	public static string strerror(int n);
	
	public static char* strtok(string s, const string ct);
	
	public static size_t strxfrm(string s, const string ct, size_t n);
	
	public static unsafe void* memcpy(void* s, const void* ct, size_t n);
	
	public static unsafe void* memmove(void* s, const void* ct, size_t n);
	
	public static unsafe int memcmp(const void* cs, const void* ct, size_t n);

	public static unsafe void* memchr(const void* cs, int c, size_t n);
	
	public static unsafe void* memset(void* s, int c, size_t n);
}

#include("stdio.h") 

namespace std.io {

	public typedef NULL null;

	/** Size of buffer used by setbuf. */
	public static const uint BUFSIZ;
	
	/** Value used to indicate end-of-stream or to report an error. */
	public static const int EOF;
    
    /** Maximum length required for array of characters to hold a filename. */
    public static const int FILENAME_MAX = #cxx_resolve("FILENAME_MAX");

    /** Maximum number of files which may be open simultaneously. */
    public static const int FOPEN_MAX = @resolve("FOPEN_MAX") 0;
    
    /** Number of characters required for temporary filename generated by tmpnam. */
    public static const int L_tmpnam = @resolve("L_tmpnam") 0;
    
    /** Value for origin argument to fseek specifying current file position. */
    public static const int SEEK_CUR = @resolve("SEEK_CUR") 0;

    /** Value for origin argument to fseek specifying end of file. */
    public static const int SEEK_END = @resolve("SEEK_END") 0;
    
    /** Value for origin argument to fseek specifying beginning of file. */
    public static const int SEEK_SET = @resolve("SEEK_SET") 0;

    /** Minimum number of unique filenames generated by calls to tmpnam. */
    public static const int TMP_MAX = @resolve("TMP_MAX") 0;

    /** Value for mode argument to setvbuf specifying full buffering. */
    public static const int _IOFBF = @resolve("_IOFBF") 0;

    /** Value for mode argument to setvbuf specifying line buffering. */
    public static const int _IOLBF = @resolve("_IOLBF") 0;
    
    /** Value for mode argument to setvbuf specifying no buffering. */
    public static const int _IONBF = @resolve("_IOLBF") 0;
    
    /** File pointer for standard input stream. Automatically opened when program execution begins. */
    public static const int stdin = @resolve("stdin") 0;
    
    /** File pointer for standard output stream. Automatically opened when program execution begins. */
	public static const int stdout = null;
    
    /** File pointer for standard error stream. Automatically opened when program execution begins. */
	public static const int stderr = null;
    
    /** Type of object holding information necessary to control a stream. */
	public binding<FILE> File {}
    
    /** Type for objects declared to store file position information. */
	public static const int fpos_t = 0;
    
    /** Type for objects declared to store result of sizeof operator. */
	public static const int size_t = 0;
    
    
	FILE* fopen(const string filename, const string mode);

	FILE* freopen(const char* filename, const char* mode, FILE* stream);

	int fflush(FILE* stream);
    
	int fclose(FILE* stream);

	int remove(const char* filename);
    
	int rename(const char* oldname, const char* newname);

	FILE* tmpfile();

	string tmpnam(char s[L_tmpnam]);

	int setvbuf(FILE* stream, char* buf, int mode, size_t size);

	void setbuf(FILE* stream, char* buf);

	int fprintf(FILE* stream, const char* format, ...);
	
	int printf(const char* format, ...);

	int sprintf(char* s, const char* format, ...);

	int vfprintf(FILE* stream, const char* format, va_list arg);

	int vprintf(const char* format, va_list arg);

	int vsprintf(char* s, const char* format, va_list arg);

	int fscanf(FILE* stream, const char* format, ...);

	int scanf(const char* format, ...);

	int sscanf(char* s, const char* format, ...);

	int fgetc(FILE* stream);

	char* fgets(char* s, int n, FILE* stream);

	int fputc(int c, FILE* stream);

	char* fputs(const char* s, FILE* stream);

	int getc(FILE* stream);

	int getchar(void);

	char* gets(char* s);

	int putc(int c, FILE* stream);

	int putchar(int c);

	int puts(const char* s);

	int ungetc(int c, FILE* stream);

	size_t fread(void* ptr, size_t size, size_t nobj, FILE* stream);

	size_t fwrite(const void* ptr, size_t size, size_t nobj, FILE* stream);

	int fseek(FILE* stream, long offset, int origin);

	long ftell(FILE* stream);

	void rewind(FILE* stream);

	int fgetpos(FILE* stream, fpos_t* ptr);

	int fsetpos(FILE* stream, const fpos_t* ptr);

	void clearerr(FILE* stream);

	int feof(FILE* stream);

	int ferror(FILE* stream);

	void perror(const char* s);

    fprintf(stderr, "%s: %s\n", (s != NULL ? s : ""), strerror(errno))

}
